#include "PSU_Protocol_FSM.h"

// =============================================================================
// Private Methods Implementation
// =============================================================================

void PSUProtocolFSM::sendCommandPacket(uint8_t psuAddress, uint8_t magicByte, const uint8_t* data, uint8_t dataLength) {
    uint8_t totalDataLength = 2 + dataLength; // Include CMD and magic bytes
    uint8_t packet[5 + dataLength];           // Full packet buffer

    // Build packet header
    packet[0] = 0x00;                         // Always 0x00
    packet[1] = totalDataLength;              // Total data length
    packet[2] = CMD_BYTE;                     // Always 0xC8
    packet[3] = magicByte;                    // Command-specific magic byte

    // Copy data payload if provided
    if (data && dataLength > 0) {
        for (int i = 0; i < dataLength; i++) {
            packet[4 + i] = data[i];
        }
    }

    // Calculate CRC (simple sum of all bytes)
    uint8_t crc = 0;
    for (int i = 0; i < 4 + dataLength; i++) {
        crc += packet[i];
    }
    packet[4 + dataLength] = crc;

    // Transmit packet with inter-byte delays
    delay(command_delay);
    for (int i = 0; i < 5 + dataLength; i++) {
        UART9.write9(packet[i]);
        delayMicroseconds(inter_byte_delay);
    }
}

PSUPacket PSUProtocolFSM::receiveAndValidatePacket(uint8_t expectedAddress, uint8_t expectedMagic) {
    PSUPacket packet;
    packet.valid = false;

    // Read packet header (3 bytes)
    uint16_t header[3];
    for (int i = 0; i < 3; i++) {
        header[i] = UART9.read9WithTimeout();
        if (header[i] == 0xFFFF) {
            quietPrintln("Timeout reading packet header");
            return packet;
        }
    }

    packet.address = header[0];
    packet.zeroByte = header[1];
    packet.dataLength = header[2];

    // Validate header structure
    if (packet.zeroByte != 0x00) {
        quietPrint("Invalid packet: zero byte should be 0x00, got ");
        quietPrintHex(packet.zeroByte);
        quietPrintln("");
        return packet;
    }

    if (expectedAddress != 0xFF && packet.address != expectedAddress) {
        quietPrint("Address mismatch: expected ");
        quietPrintNum(expectedAddress);
        quietPrint(", got ");
        quietPrintNum(packet.address);
        quietPrintln("");
        return packet;
    }

    // Read command and magic bytes
    packet.commandByte = UART9.read9WithTimeout();
    packet.magicByte = UART9.read9WithTimeout();

    if (packet.commandByte == 0xFFFF || packet.magicByte == 0xFFFF) {
        quietPrintln("Timeout reading command/magic bytes");
        return packet;
    }

    // Validate command byte
    if (packet.commandByte != CMD_BYTE) {
        quietPrint("Invalid command byte: expected 0xC8, got ");
        quietPrintHex(packet.commandByte);
        quietPrintln("");
        return packet;
    }

    // SPECIAL CASE: Handle AC power status packet (0x023)
    if (packet.magicByte == MAGIC_EXTENDED_STATUS) {
        // Read the full AC status packet data
        if (packet.dataLength > 2) {
            uint8_t remainingData = packet.dataLength - 2;
            packet.data = (uint8_t*)malloc(remainingData);

            for (int i = 0; i < remainingData; i++) {
                uint16_t dataByte = UART9.read9WithTimeout();
                if (dataByte == 0xFFFF) {
                    free(packet.data);
                    packet.data = nullptr;
                    quietPrintln("Timeout reading AC status data");
                    return packet;
                }
                packet.data[i] = dataByte;
            }
        }

        // Read and validate CRC
        packet.crc = UART9.read9WithTimeout();
        if (packet.crc == 0xFFFF) {
            if (packet.data) free(packet.data);
            quietPrintln("Timeout reading CRC for AC status");
            return packet;
        }

        // Validate CRC for AC status packet
        uint8_t calculatedCRC = 0;
        calculatedCRC += packet.address;
        calculatedCRC += packet.zeroByte;
        calculatedCRC += packet.dataLength;
        calculatedCRC += packet.commandByte;
        calculatedCRC += packet.magicByte;

        if (packet.data) {
            for (int i = 0; i < packet.dataLength - 2; i++) {
                calculatedCRC += packet.data[i];
            }
        }

        if (calculatedCRC != packet.crc) {
            quietPrint("AC status CRC mismatch: calculated ");
            quietPrintHex(calculatedCRC);
            quietPrint(", received ");
            quietPrintHex(packet.crc);
            quietPrintln("");
            if (packet.data) free(packet.data);
            return packet;
        }

        packet.valid = true;
        quietPrint("Valid AC status packet from PSU:");
        quietPrintNum(packet.address);
        quietPrintln("");
        return packet;
    }

    // Validate magic byte if expected (only for non-AC-status packets)
    if (expectedMagic != 0xFF && packet.magicByte != expectedMagic) {
        quietPrint("Magic byte mismatch: expected ");
        quietPrintHex(expectedMagic);
        quietPrint(", got ");
        quietPrintHex(packet.magicByte);
        quietPrintln("");
        return packet;
    }

    // Allocate and read data payload for normal packets
    if (packet.dataLength > 2) {
        uint8_t remainingData = packet.dataLength - 2;
        packet.data = (uint8_t*)malloc(remainingData);

        for (int i = 0; i < remainingData; i++) {
            uint16_t dataByte = UART9.read9WithTimeout();
            if (dataByte == 0xFFFF) {
                free(packet.data);
                quietPrintln("Timeout reading packet data");
                return packet;
            }
            packet.data[i] = dataByte;
        }
    }

    // Read and validate CRC for normal packets
    packet.crc = UART9.read9WithTimeout();
    if (packet.crc == 0xFFFF) {
        if (packet.data) free(packet.data);
        quietPrintln("Timeout reading CRC");
        return packet;
    }

    // Calculate expected CRC
    uint8_t calculatedCRC = 0;
    calculatedCRC += packet.address;
    calculatedCRC += packet.zeroByte;
    calculatedCRC += packet.dataLength;
    calculatedCRC += packet.commandByte;
    calculatedCRC += packet.magicByte;

    if (packet.data) {
        for (int i = 0; i < packet.dataLength - 2; i++) {
            calculatedCRC += packet.data[i];
        }
    }

    if (calculatedCRC != packet.crc) {
        quietPrint("CRC mismatch: calculated ");
        quietPrintHex(calculatedCRC);
        quietPrint(", received ");
        quietPrintHex(packet.crc);
        quietPrintln("");
        if (packet.data) free(packet.data);
        return packet;
    }

    packet.valid = true;
    quietPrint("Valid packet: magic=0x");
    quietPrintHex(packet.magicByte);
    quietPrint(", len=");
    quietPrintNum(packet.dataLength);
    quietPrintln("");

    return packet;
}

ACStatusInfo PSUProtocolFSM::processACStatusPacket(const PSUPacket& packet) {
    ACStatusInfo info;
    info.valid = false;

    if (!packet.valid || packet.magicByte != MAGIC_EXTENDED_STATUS) {
        return info;
    }

    // Store raw data for analysis
    if (packet.data && packet.dataLength >= 17) {
        memcpy(info.rawData, packet.data, 17);

        // Analyze AC status based on your reverse engineering:
        // AC restored: data[5] = 0x00
        // AC lost: data[5] = 0x01
        if (packet.data[5] == 0x00) {
            info.status = ACStatus::POWER_GOOD;
            info.valid = true;
            quietPrintln("AC_STATUS: POWER GOOD");
        } else if (packet.data[5] == 0x01) {
            info.status = ACStatus::POWER_LOST;
            info.valid = true;
            quietPrintln("AC_STATUS: POWER LOST");
        } else {
            quietPrint("AC_STATUS: UNKNOWN CODE:0x");
            quietPrintHex(packet.data[5]);
            quietPrintln("");
        }
    }

    return info;
}

void PSUProtocolFSM::freePacket(PSUPacket& packet) {
    if (packet.data) {
        free(packet.data);
        packet.data = nullptr;
    }
}

bool PSUProtocolFSM::handleVoltageCurrentPacket(const PSUPacket& packet, void* result) {
    if (!packet.valid || packet.magicByte != MAGIC_VOLTAGE_CURRENT) {
        return false;
    }

    PSUMeasurement* measurement = (PSUMeasurement*)result;

    // Need at least 9 bytes total (C8+magic+7 data bytes)
    if (packet.dataLength >= 9) {
        // Voltage: bytes 8-9 in data section (indices 3-4 in data array)
        uint16_t voltageRaw = (packet.data[3] << 8) | packet.data[4];
        // Current: bytes 10-11 in data section (indices 5-6 in data array)
        uint16_t currentRaw = (packet.data[5] << 8) | packet.data[6];

        measurement->voltage = voltageRaw / 100.0; // Convert to volts
        measurement->current = currentRaw / 100.0; // Convert to amps
        measurement->success = true;

        // Cache the data for menu display
        uint8_t psuAddr = packet.address;
        if (psuAddr < PSU_COUNT) {
            psuLastVoltage[psuAddr] = measurement->voltage;
            psuLastCurrent[psuAddr] = measurement->current;
            psuLastQueryTime[psuAddr] = millis();
            psuDataValid[psuAddr] = true;
        }

        // Convert floats to strings for printing
        char voltageStr[10];
        char currentStr[10];
        dtostrf(measurement->voltage, 4, 2, voltageStr);  // 4 width, 2 decimals
        dtostrf(measurement->current, 4, 2, currentStr);  // 4 width, 2 decimals

        quietPrint("V:");
        quietPrint(voltageStr);
        quietPrint("V I:");
        quietPrint(currentStr);
        quietPrintln("A");

        return true;
    }

    quietPrint("Packet too short for V/I data. Len:");
    quietPrintNum(packet.dataLength);
    quietPrintln("");
    return false;
}

void PSUProtocolFSM::quietPrint(const char* str) {
    if (!UART9.available()) {
        Debug.print(str);
    }
}

void PSUProtocolFSM::quietPrintln(const char* str) {
    if (!UART9.available()) {
        Debug.println(str);
    }
}

void PSUProtocolFSM::quietPrintHex(uint16_t num) {
    if (!UART9.available()) {
        Debug.printHex(num);
    }
}

void PSUProtocolFSM::quietPrintNum(uint8_t num) {
    if (!UART9.available()) {
        char buffer[4];
        itoa(num, buffer, 10);
        Debug.print(buffer);
    }
}

void PSUProtocolFSM::checkPSUDisappearance() {
    uint32_t now = millis();
    for (int i = 0; i < PSU_COUNT; i++) {
        if (psuPresent[i] && (now - psuLastSeen[i] > disappearanceTimeout)) {
            // PSU hasn't responded recently - verify if it's really gone
            uint16_t discoveryByte = PSU_BASE_ADDRESS + i;
            UART9.clearBuffer();
            UART9.write9(discoveryByte);
            delay(discover_delay);

            bool stillPresent = false;
            uint32_t verifyStart = millis();

            // Wait briefly for response to verify presence
            while (millis() - verifyStart < 100) {
                if (UART9.available()) {
                    uint16_t response = UART9.read9();
                    // Valid responses: 0x073 (initialized) or address byte (uninitialized)
                    if (response == PSU_NO_DATA || response == i) {
                        stillPresent = true;
                        psuLastSeen[i] = millis(); // Update last seen time
                        break;
                    }
                }
            }

            if (!stillPresent) {
                // PSU is confirmed gone - update state
                psuPresent[i] = false;
                psuInitialized[i] = false;
                psuACStatus[i] = ACStatus::UNKNOWN;
                quietPrint("PSU_GONE:");
                quietPrintNum(i);
                quietPrintln("");
            }
        }
    }
}

void PSUProtocolFSM::updateDiscovery() {
    // ONLY run discovery when completely idle AND bus is clear for sufficient time
    if (currentTransaction.state != PSUState::IDLE) return;

    // Wait for bus to be completely idle for at least 10ms
    static uint32_t lastBusActivity = 0;
    if (UART9.available()) {
        lastBusActivity = millis();
        return; // Bus is active, don't interfere
    }

    // Only proceed if bus has been idle for safe period
    if (millis() - lastBusActivity < 20) return;

    if (millis() - lastDiscoveryTime >= discoveryInterval) {
        // Send discovery packet to current address
        uint16_t discoveryByte = PSU_BASE_ADDRESS + currentDiscoveryAddress;
        UART9.clearBuffer();
        UART9.write9(discoveryByte);
        delay(discover_delay);

        currentTransaction.command = PSUCommand::DISCOVER;
        currentTransaction.psuAddress = currentDiscoveryAddress;
        currentTransaction.state = PSUState::DISCOVER_WAIT_RESPONSE;
        currentTransaction.stateStartTime = millis();

        currentDiscoveryAddress = (currentDiscoveryAddress + 1) % PSU_COUNT;
        lastDiscoveryTime = millis();
        lastBusActivity = millis(); // Reset bus activity timer
    }
}

PSUState PSUProtocolFSM::handleACPowerStatus(const PSUPacket& packet) {
    currentTransaction.acStatus = processACStatusPacket(packet);

    if (currentTransaction.acStatus.valid) {
        // Update global AC status for this PSU
        psuACStatus[currentTransaction.psuAddress] = currentTransaction.acStatus.status;

        if (currentTransaction.acStatus.status == ACStatus::POWER_LOST) {
            quietPrint("PSU:");
            quietPrintNum(currentTransaction.psuAddress);
            quietPrintln(" HAS NO AC POWER - OPERATION IMPOSSIBLE");

            // For set operations, we can't proceed without AC power
            if (currentTransaction.command == PSUCommand::SET_VOLTAGE_CURRENT) {
                return PSUState::COMPLETE_ERROR;
            }
        }

        // For query operations, we might still get data even with AC loss
        // but the PSU might not be able to provide meaningful measurements
    }

    // Free the packet data
    freePacket(const_cast<PSUPacket&>(packet));

    // Return to appropriate wait state based on current operation
    switch (currentTransaction.command) {
        case PSUCommand::INITIALIZE:
            return PSUState::AUTO_INIT_WAIT_FINAL_RESPONSE;
        case PSUCommand::QUERY_VOLTAGE_CURRENT:
            return PSUState::QUERY_WAIT_DATA_PACKET;
        case PSUCommand::SET_VOLTAGE_CURRENT:
            return PSUState::SET_WAIT_DATA_PACKET;
        default:
            return PSUState::COMPLETE_ERROR;
    }
}

// =============================================================================
// Public Methods Implementation
// =============================================================================

void PSUProtocolFSM::begin() {
    currentTransaction.state = PSUState::IDLE;
    for (int i = 0; i < PSU_COUNT; i++) {
        psuInitialized[i] = false;
        psuPresent[i] = false;
        psuACStatus[i] = ACStatus::UNKNOWN;
        psuLastSeen[i] = 0;
        // Initialize data cache
        psuLastVoltage[i] = 0.0;
        psuLastCurrent[i] = 0.0;
        psuLastQueryTime[i] = 0;
        psuDataValid[i] = false;
    }
    currentDiscoveryAddress = 0;
    lastDiscoveryTime = 0;
    discoveryInterval = 1000;
    disappearanceTimeout = 5000;
    ack_delay = 2;
    command_delay = 2;
    inter_byte_delay = 100;
    discover_delay = 2;
    Debug.println("FSM Ready - AC Status Aware");
}

void PSUProtocolFSM::update() {
    // Check for PSUs that may have disappeared
    checkPSUDisappearance();

    // Handle continuous background discovery
    updateDiscovery();

    // Process current transaction if active
    if (!isBusy()) return;

    // Handle state timeout
    if (millis() - currentTransaction.stateStartTime > STATE_TIMEOUT) {
        if (currentTransaction.state == PSUState::DISCOVER_WAIT_RESPONSE) {
            // Discovery timeout - no PSU at this address
            psuPresent[currentTransaction.psuAddress] = false;
            psuInitialized[currentTransaction.psuAddress] = false;
            psuACStatus[currentTransaction.psuAddress] = ACStatus::UNKNOWN;
        }
        quietPrintln("TIMEOUT");
        currentTransaction.state = PSUState::TIMEOUT_ERROR;
    }

    // State machine processing
    switch (currentTransaction.state) {
        case PSUState::DISCOVER_WAIT_RESPONSE:
            if (UART9.available()) {
                uint16_t response = UART9.read9();

                if (response == PSU_NO_DATA) {
                    // PSU is initialized and responding normally
                    psuPresent[currentTransaction.psuAddress] = true;
                    psuLastSeen[currentTransaction.psuAddress] = millis();
                    psuInitialized[currentTransaction.psuAddress] = true;
                    currentTransaction.state = PSUState::COMPLETE_SUCCESS;
                } else {
                    // Check if this is an uninitialized PSU response
                    uint8_t addressByte = response;
                    uint16_t zeroByte = UART9.read9WithTimeout();
                    uint16_t dataLength = UART9.read9WithTimeout();

                    if (zeroByte != 0xFFFF && dataLength != 0xFFFF &&
                        addressByte == currentTransaction.psuAddress && zeroByte == 0x00) {
                        // Found uninitialized PSU - proceed to auto-initialization
                        psuPresent[currentTransaction.psuAddress] = true;
                        psuLastSeen[currentTransaction.psuAddress] = millis();
                        quietPrint("FOUND_UNINIT:");
                        quietPrintNum(currentTransaction.psuAddress);
                        quietPrintln("");
                        currentTransaction.state = PSUState::DISCOVER_PROCESS_RESPONSE;
                    } else {
                        // Invalid response or no PSU present
                        psuPresent[currentTransaction.psuAddress] = false;
                        psuInitialized[currentTransaction.psuAddress] = false;
                        psuACStatus[currentTransaction.psuAddress] = ACStatus::UNKNOWN;
                        currentTransaction.state = PSUState::COMPLETE_ERROR;
                    }
                }
            }
            break;

        case PSUState::DISCOVER_PROCESS_RESPONSE:
            {
                // Read and discard remaining packet
                while (UART9.available()) {
                    UART9.read9();
                }
                // Start auto-initialization
                currentTransaction.initRetryCount = 0;
                currentTransaction.state = PSUState::AUTO_INIT_SEND_ACK;
                currentTransaction.stateStartTime = millis();
            }
            break;

        case PSUState::AUTO_INIT_SEND_ACK:
            if (UART9.available()) {
            // Bus is busy - wait
                break;
            }
            UART9.clearBuffer();
            UART9.waitForBusIdle(5);
            UART9.write9(PSU_ACK);
            delay(ack_delay);
            currentTransaction.state = PSUState::AUTO_INIT_SEND_ADDRESS_CMD;
            currentTransaction.stateStartTime = millis();
            break;

        case PSUState::AUTO_INIT_SEND_ADDRESS_CMD:
            {
                uint16_t initCmd = INIT_COMMAND + currentTransaction.psuAddress;
                UART9.write9(initCmd);
                currentTransaction.state = PSUState::AUTO_INIT_WAIT_ADDRESS_RESPONSE;
                currentTransaction.stateStartTime = millis();
            }
            break;

        case PSUState::AUTO_INIT_WAIT_ADDRESS_RESPONSE:
            if (UART9.available()) {
                uint16_t response = UART9.read9();
                if (response == currentTransaction.psuAddress) {
                    currentTransaction.state = PSUState::AUTO_INIT_SEND_COMMAND_PACKET;
                } else {
                    currentTransaction.state = PSUState::COMPLETE_ERROR;
                }
            }
            break;

        case PSUState::AUTO_INIT_SEND_COMMAND_PACKET:
            {
                static const uint8_t initData[] = {0xFF, 0xFF}; // Initialization data
                sendCommandPacket(currentTransaction.psuAddress, INIT_MAGIC_BYTE, initData, sizeof(initData));
                currentTransaction.state = PSUState::AUTO_INIT_WAIT_COMMAND_ACK;
                currentTransaction.stateStartTime = millis();
            }
            break;

        case PSUState::AUTO_INIT_WAIT_COMMAND_ACK:
            if (UART9.available()) {
                uint16_t response = UART9.read9();
                if (response == PSU_ACK) {
                    delay(command_delay);
                    currentTransaction.state = PSUState::AUTO_INIT_SEND_FINAL_ADDRESS;
                } else {
                    currentTransaction.state = PSUState::COMPLETE_ERROR;
                }
            }
            break;

        case PSUState::AUTO_INIT_SEND_FINAL_ADDRESS:
            {
                uint16_t finalByte = PSU_BASE_ADDRESS + currentTransaction.psuAddress;
                UART9.write9(finalByte);
                currentTransaction.state = PSUState::AUTO_INIT_WAIT_FINAL_RESPONSE;
                currentTransaction.stateStartTime = millis();
            }
            break;

        case PSUState::AUTO_INIT_WAIT_FINAL_RESPONSE:
            if (UART9.available()) {
                uint16_t response = UART9.read9();
                if (response == PSU_NO_DATA) {
                    // Initialization successful - send final ACK
                    UART9.waitForBusIdle(5);
                    UART9.write9(PSU_ACK);
                    psuInitialized[currentTransaction.psuAddress] = true;
                    quietPrint("AUTO_INIT_OK:");
                    quietPrintNum(currentTransaction.psuAddress);
                    quietPrintln("");
                    currentTransaction.state = PSUState::COMPLETE_SUCCESS;
                } else if (response == currentTransaction.psuAddress) {
                    // Got address byte - receive and analyze the packet
                    PSUPacket statusPacket = receiveAndValidatePacket(currentTransaction.psuAddress);
                    if (statusPacket.valid) {
                        if (statusPacket.magicByte == MAGIC_EXTENDED_STATUS) {
                            currentTransaction.state = PSUState::AUTO_INIT_HANDLE_AC_POWER_STATUS;
                        } else {
                            freePacket(statusPacket);
                            quietPrint("UNEXPECTED_PKT_IN_INIT:0x");
                            quietPrintHex(statusPacket.magicByte);
                            quietPrintln("");
                            currentTransaction.state = PSUState::COMPLETE_ERROR;
                        }
                    } else {
                        currentTransaction.state = PSUState::COMPLETE_ERROR;
                    }
                } else {
                    // Unexpected response
                    quietPrint("UNEXPECTED_RESP_IN_INIT:0x");
                    quietPrintHex(response);
                    quietPrintln("");
                    currentTransaction.state = PSUState::COMPLETE_ERROR;
                }
            }
            break;

        case PSUState::AUTO_INIT_HANDLE_AC_POWER_STATUS:
            {
                // Recreate the packet from stored transaction data
                PSUPacket acPacket;
                acPacket.address = currentTransaction.psuAddress;
                acPacket.magicByte = MAGIC_EXTENDED_STATUS;
                // Note: We'd need to store the actual packet data to process it properly
                // For now, we'll handle this in the main AC status handler
                currentTransaction.state = handleACPowerStatus(acPacket);
            }
            break;

        // =================================================================
        // Query States for Voltage/Current Reading
        // =================================================================
        case PSUState::QUERY_SEND_ADDRESS_CMD:
            if (UART9.available()) {
            // Bus is busy - wait
                break;
                }
            {
                uint16_t addressCmd = INIT_COMMAND + currentTransaction.psuAddress;
                UART9.clearBuffer();
                UART9.waitForBusIdle(5);
                UART9.write9(addressCmd);
                currentTransaction.state = PSUState::QUERY_WAIT_ADDRESS_RESPONSE;
                currentTransaction.stateStartTime = millis();
            }
            break;

        case PSUState::QUERY_WAIT_ADDRESS_RESPONSE:
            if (UART9.available()) {
                uint16_t response = UART9.read9();
                if (response == currentTransaction.psuAddress) {
                    currentTransaction.state = PSUState::QUERY_SEND_COMMAND_PACKET;
                } else {
                    quietPrint("Query addr err:");
                    quietPrintHex(response);
                    quietPrintln("");
                    currentTransaction.state = PSUState::COMPLETE_ERROR;
                }
            }
            break;

        case PSUState::QUERY_SEND_COMMAND_PACKET:
            {
                static const uint8_t queryData[] = {0xFF, 0xFF}; // Standard query data
                sendCommandPacket(currentTransaction.psuAddress, currentTransaction.magicByte,
                                 queryData, sizeof(queryData));
                currentTransaction.state = PSUState::QUERY_WAIT_COMMAND_ACK;
                currentTransaction.stateStartTime = millis();
            }
            break;

        case PSUState::QUERY_WAIT_COMMAND_ACK:
            if (UART9.available()) {
                uint16_t response = UART9.read9();
                if (response == PSU_ACK) {
                    delay(command_delay);
                    currentTransaction.state = PSUState::QUERY_SEND_FINAL_ADDRESS;
                } else {
                    quietPrint("Query ACK err:");
                    quietPrintHex(response);
                    quietPrintln("");
                    currentTransaction.state = PSUState::COMPLETE_ERROR;
                }
            }
            break;

        case PSUState::QUERY_SEND_FINAL_ADDRESS:
            {
                uint16_t finalByte = PSU_BASE_ADDRESS + currentTransaction.psuAddress;
                UART9.write9(finalByte);
                currentTransaction.state = PSUState::QUERY_WAIT_DATA_PACKET;
                currentTransaction.stateStartTime = millis();
            }
            break;

        case PSUState::QUERY_WAIT_DATA_PACKET:
        {
            PSUPacket packet = receiveAndValidatePacket(currentTransaction.psuAddress);
            if (packet.valid) {
                if (packet.magicByte == MAGIC_VOLTAGE_CURRENT) {
                    // Expected query response
                    currentTransaction.txData = (const uint8_t*)packet.data;
                    currentTransaction.txDataLength = packet.dataLength;
                    currentTransaction.state = PSUState::QUERY_PROCESS_DATA_PACKET;
                }
                else if (packet.magicByte == MAGIC_EXTENDED_STATUS) {
                    // AC power status received during query
                    currentTransaction.state = PSUState::QUERY_HANDLE_AC_POWER_STATUS;
                    // Store packet data for processing
                    currentTransaction.txData = (const uint8_t*)packet.data;
                    currentTransaction.txDataLength = packet.dataLength;
                }
                else {
                    freePacket(packet);
                    quietPrint("UNKNOWN_MAGIC_IN_QUERY:0x");
                    quietPrintHex(packet.magicByte);
                    quietPrintln("");
                    currentTransaction.state = PSUState::COMPLETE_ERROR;
                }
            } else {
                currentTransaction.state = PSUState::COMPLETE_ERROR;
            }
        }
        break;

        case PSUState::QUERY_HANDLE_AC_POWER_STATUS:
            {
                // Process AC status and decide next action
                PSUPacket acPacket;
                acPacket.data = (uint8_t*)currentTransaction.txData;
                acPacket.dataLength = currentTransaction.txDataLength;
                acPacket.magicByte = MAGIC_EXTENDED_STATUS;
                acPacket.valid = true;

                currentTransaction.state = handleACPowerStatus(acPacket);
                currentTransaction.txData = nullptr;
                currentTransaction.txDataLength = 0;
            }
            break;

        case PSUState::QUERY_PROCESS_DATA_PACKET:
            {
                // Process the received data packet
                PSUPacket packet;
                packet.data = (uint8_t*)currentTransaction.txData;
                packet.dataLength = currentTransaction.txDataLength;
                packet.magicByte = currentTransaction.magicByte;
                packet.valid = true;

                bool processed = false;
                if (currentTransaction.command == PSUCommand::QUERY_VOLTAGE_CURRENT && currentTransaction.result) {
                    processed = handleVoltageCurrentPacket(packet, currentTransaction.result);
                }

                freePacket(packet);
                currentTransaction.txData = nullptr;
                currentTransaction.txDataLength = 0;

                if (processed) {
                    currentTransaction.state = PSUState::QUERY_SEND_FINAL_ACK;
                } else {
                    currentTransaction.state = PSUState::COMPLETE_ERROR;
                }
            }
            break;

        case PSUState::QUERY_SEND_FINAL_ACK:
            UART9.write9(PSU_ACK);
            currentTransaction.state = PSUState::COMPLETE_SUCCESS;
            break;

        // =================================================================
        // Set Voltage/Current States
        // =================================================================
        case PSUState::SET_SEND_ADDRESS_CMD:
                if (UART9.available()) {
                // Bus is busy - wait
                break;
                }
            {
                uint16_t addressCmd = INIT_COMMAND + currentTransaction.psuAddress;
                UART9.clearBuffer();
                UART9.waitForBusIdle(5);
                UART9.write9(addressCmd);
                currentTransaction.state = PSUState::SET_WAIT_ADDRESS_RESPONSE;
                currentTransaction.stateStartTime = millis();
            }
            break;

        case PSUState::SET_WAIT_ADDRESS_RESPONSE:
            if (UART9.available()) {
                uint16_t response = UART9.read9();
                if (response == currentTransaction.psuAddress) {
                    currentTransaction.state = PSUState::SET_SEND_COMMAND_PACKET;
                } else {
                    quietPrint("Set addr err:");
                    quietPrintHex(response);
                    quietPrintln("");
                    currentTransaction.state = PSUState::COMPLETE_ERROR;
                }
            }
            break;

        case PSUState::SET_SEND_COMMAND_PACKET:
            {
                // Use the provided set data (voltage/current values)
                sendCommandPacket(currentTransaction.psuAddress, currentTransaction.magicByte,
                                 currentTransaction.txData, currentTransaction.txDataLength);
                currentTransaction.state = PSUState::SET_WAIT_COMMAND_ACK;
                currentTransaction.stateStartTime = millis();
            }
            break;

        case PSUState::SET_WAIT_COMMAND_ACK:
            if (UART9.available()) {
                uint16_t response = UART9.read9();
                if (response == PSU_ACK) {
                    delay(command_delay);
                    currentTransaction.state = PSUState::SET_SEND_FINAL_ADDRESS;
                } else {
                    quietPrint("Set ACK err:");
                    quietPrintHex(response);
                    quietPrintln("");
                    currentTransaction.state = PSUState::COMPLETE_ERROR;
                }
            }
            break;

        case PSUState::SET_SEND_FINAL_ADDRESS:
            {
                uint16_t finalByte = PSU_BASE_ADDRESS + currentTransaction.psuAddress;
                UART9.write9(finalByte);
                currentTransaction.state = PSUState::SET_WAIT_DATA_PACKET;
                currentTransaction.stateStartTime = millis();
            }
            break;

        case PSUState::SET_WAIT_DATA_PACKET:
        {
            PSUPacket packet = receiveAndValidatePacket(currentTransaction.psuAddress);
            if (packet.valid) {
                if (packet.magicByte == MAGIC_SET_VOLTAGE_CURRENT) {
                    // Expected set confirmation
                    currentTransaction.txData = (const uint8_t*)packet.data;
                    currentTransaction.txDataLength = packet.dataLength;
                    currentTransaction.state = PSUState::SET_PROCESS_DATA_PACKET;
                }
                else if (packet.magicByte == MAGIC_EXTENDED_STATUS) {
                    // AC power status received during set operation
                    currentTransaction.state = PSUState::SET_HANDLE_AC_POWER_STATUS;
                    // Store packet data for processing
                    currentTransaction.txData = (const uint8_t*)packet.data;
                    currentTransaction.txDataLength = packet.dataLength;
                }
                else {
                    freePacket(packet);
                    quietPrint("UNKNOWN_MAGIC_IN_SET:0x");
                    quietPrintHex(packet.magicByte);
                    quietPrintln("");
                    currentTransaction.state = PSUState::COMPLETE_ERROR;
                }
            } else {
                currentTransaction.state = PSUState::COMPLETE_ERROR;
            }
        }
        break;

        case PSUState::SET_HANDLE_AC_POWER_STATUS:
            {
                // Process AC status - if power is lost, set operation will fail
                PSUPacket acPacket;
                acPacket.data = (uint8_t*)currentTransaction.txData;
                acPacket.dataLength = currentTransaction.txDataLength;
                acPacket.magicByte = MAGIC_EXTENDED_STATUS;
                acPacket.valid = true;

                currentTransaction.state = handleACPowerStatus(acPacket);
                currentTransaction.txData = nullptr;
                currentTransaction.txDataLength = 0;
            }
            break;

        case PSUState::SET_PROCESS_DATA_PACKET:
            {
                // Process set confirmation (optional - can just check if packet is valid)
                PSUPacket packet;
                packet.data = (uint8_t*)currentTransaction.txData;
                packet.dataLength = currentTransaction.txDataLength;
                packet.magicByte = currentTransaction.magicByte;
                packet.valid = true;

                // For set operations, we just need to confirm the packet was received
                freePacket(packet);
                currentTransaction.txData = nullptr;
                currentTransaction.txDataLength = 0;

                currentTransaction.state = PSUState::SET_SEND_FINAL_ACK;
            }
            break;

        case PSUState::SET_SEND_FINAL_ACK:
            UART9.write9(PSU_ACK);
            currentTransaction.state = PSUState::COMPLETE_SUCCESS;
            break;

        case PSUState::COMPLETE_SUCCESS:
            currentTransaction.success = true;
            currentTransaction.state = PSUState::IDLE;
            break;

        case PSUState::COMPLETE_ERROR:
            currentTransaction.success = false;
            currentTransaction.state = PSUState::IDLE;
            break;

        case PSUState::TIMEOUT_ERROR:
            currentTransaction.success = false;
            currentTransaction.state = PSUState::IDLE;
            break;

        default:
            break;
    }
}

// =============================================================================
// Timing Configuration Methods
// =============================================================================

void PSUProtocolFSM::setAckDelay(uint8_t ms) { ack_delay = ms; }
void PSUProtocolFSM::setCommandDelay(uint8_t ms) { command_delay = ms; }
void PSUProtocolFSM::setInterByteDelay(uint16_t us) { inter_byte_delay = us; }
void PSUProtocolFSM::setDiscoverDelay(uint8_t ms) { discover_delay = ms; }
void PSUProtocolFSM::setDiscoveryInterval(uint32_t ms) { discoveryInterval = ms; }
void PSUProtocolFSM::setDisappearanceTimeout(uint32_t ms) { disappearanceTimeout = ms; }

// =============================================================================
// Status Query Methods
// =============================================================================

bool PSUProtocolFSM::isPSUInitialized(uint8_t psuAddress) {
    return psuInitialized[psuAddress];
}

bool PSUProtocolFSM::isPSUPresent(uint8_t psuAddress) {
    return psuPresent[psuAddress];
}

ACStatus PSUProtocolFSM::getPSUACStatus(uint8_t psuAddress) {
    return psuACStatus[psuAddress];
}

bool PSUProtocolFSM::hasACPower(uint8_t psuAddress) {
    return psuACStatus[psuAddress] == ACStatus::POWER_GOOD;
}

uint8_t PSUProtocolFSM::getPSUCount() {
    uint8_t count = 0;
    for (int i = 0; i < PSU_COUNT; i++) {
        if (psuPresent[i]) count++;
    }
    return count;
}

uint8_t PSUProtocolFSM::getInitializedPSUCount() {
    uint8_t count = 0;
    for (int i = 0; i < PSU_COUNT; i++) {
        if (psuInitialized[i]) count++;
    }
    return count;
}

// =============================================================================
// Data Caching Methods
// =============================================================================

float PSUProtocolFSM::getLastVoltage(uint8_t psuAddress) {
    if (psuAddress >= PSU_COUNT) return 0.0;
    return psuLastVoltage[psuAddress];
}

float PSUProtocolFSM::getLastCurrent(uint8_t psuAddress) {
    if (psuAddress >= PSU_COUNT) return 0.0;
    return psuLastCurrent[psuAddress];
}

bool PSUProtocolFSM::isDataValid(uint8_t psuAddress) {
    if (psuAddress >= PSU_COUNT) return false;
    return psuDataValid[psuAddress];
}

uint32_t PSUProtocolFSM::getLastQueryTime(uint8_t psuAddress) {
    if (psuAddress >= PSU_COUNT) return 0;
    return psuLastQueryTime[psuAddress];
}

// =============================================================================
// Public Query Methods
// =============================================================================

bool PSUProtocolFSM::startVoltageCurrentQuery(uint8_t psuAddress, PSUMeasurement* result) {
    if (isBusy()) return false;
    if (!isPSUPresent(psuAddress) || !isPSUInitialized(psuAddress)) return false;

    currentTransaction.command = PSUCommand::QUERY_VOLTAGE_CURRENT;
    currentTransaction.psuAddress = psuAddress;
    currentTransaction.magicByte = MAGIC_VOLTAGE_CURRENT;
    currentTransaction.txData = nullptr;
    currentTransaction.txDataLength = 0;
    currentTransaction.result = result;
    currentTransaction.state = PSUState::QUERY_SEND_ADDRESS_CMD;
    currentTransaction.stateStartTime = millis();

    quietPrint("QUERY_V_I:");
    quietPrintNum(psuAddress);
    quietPrintln("");
    return true;
}

bool PSUProtocolFSM::startVoltageCurrentSet(uint8_t psuAddress, float voltage, float current, PSUMeasurement* result) {
    if (isBusy()) return false;
    if (!isPSUPresent(psuAddress) || !isPSUInitialized(psuAddress)) return false;

    // Check if PSU has AC power (set operations require AC power)
    if (!hasACPower(psuAddress)) {
        quietPrint("SET_ABORTED_NO_AC_POWER:");
        quietPrintNum(psuAddress);
        quietPrintln("");
        return false;
    }

    // Convert voltage and current to PSU format (0.01V and 0.01A units)
    uint16_t voltageRaw = (uint16_t)(voltage * 100.0);
    uint16_t currentRaw = (uint16_t)(current * 100.0);

    // Prepare set data packet: [FF][FF][voltage_H][voltage_L][current_H][current_L]
    static uint8_t setData[6];
    setData[0] = 0xFF;
    setData[1] = 0xFF;
    setData[2] = (uint8_t)((voltageRaw >> 8) & 0xFF);  // Voltage high byte
    setData[3] = (uint8_t)(voltageRaw & 0xFF);         // Voltage low byte
    setData[4] = (uint8_t)((currentRaw >> 8) & 0xFF);  // Current high byte
    setData[5] = (uint8_t)(currentRaw & 0xFF);         // Current low byte

    currentTransaction.command = PSUCommand::SET_VOLTAGE_CURRENT;
    currentTransaction.psuAddress = psuAddress;
    currentTransaction.magicByte = MAGIC_SET_VOLTAGE_CURRENT;
    currentTransaction.txData = setData;
    currentTransaction.txDataLength = sizeof(setData);
    currentTransaction.result = result;
    currentTransaction.state = PSUState::SET_SEND_ADDRESS_CMD;
    currentTransaction.stateStartTime = millis();

    // Convert floats to strings for debug
    char voltageStr[10];
    char currentStr[10];
    dtostrf(voltage, 4, 2, voltageStr);
    dtostrf(current, 4, 2, currentStr);

    quietPrint("SET_V_I:");
    quietPrintNum(psuAddress);
    quietPrint(" V:");
    quietPrint(voltageStr);
    quietPrint("V I:");
    quietPrint(currentStr);
    quietPrintln("A");

    return true;
}

bool PSUProtocolFSM::startACStatusQuery(uint8_t psuAddress, ACStatusInfo* result) {
    if (isBusy()) return false;
    if (!isPSUPresent(psuAddress) || !isPSUInitialized(psuAddress)) return false;

    currentTransaction.command = PSUCommand::QUERY_EXTENDED_STATUS;
    currentTransaction.psuAddress = psuAddress;
    currentTransaction.magicByte = MAGIC_EXTENDED_STATUS;  // 0x23
    currentTransaction.txData = nullptr;
    currentTransaction.txDataLength = 0;
    currentTransaction.result = result;
    currentTransaction.state = PSUState::QUERY_SEND_ADDRESS_CMD;
    currentTransaction.stateStartTime = millis();

    quietPrint("QUERY_AC_STATUS:");
    quietPrintNum(psuAddress);
    quietPrintln("");
    return true;
}

bool PSUProtocolFSM::isBusy() const {
    return currentTransaction.state != PSUState::IDLE;
}

bool PSUProtocolFSM::transactionSuccess() const {
    return currentTransaction.success;
}

// =============================================================================
// Global Instance Definition
// =============================================================================

PSUProtocolFSM PSUController;
